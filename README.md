# Glimmer-CS-EASY-03

## C语言内存模型

|         内存分区          |                           具体含义                           |
| :-----------------------: | :----------------------------------------------------------: |
|    程序代码区（code）     | 存放函数体的二进制代码。一个 C 语言程序由多个函数构成， C 语言程序的执行就是函数之间 的相互调用 |
|    常量区（constant）     | 存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程 序运行期间不能改变 |
| 全局数据区（global data） | 存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变 |
|       堆区（heap）        | 存放进程运行中被动态分配的内存段。一般人为分配和释放，若程序员不释放，程序运行结束时由操作系统回收**（ps.这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表）** |
|        动态链接库         |            用于在程序运行期间加载和卸载动态链接库            |
|       栈区（stack）       | 存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈 |

- 在这些内存分区中，程序代码区用来保存指令；常量区、全局数据区、堆、栈都用来保存数据
- 程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在
- 常量区和全局数据区有时也被合称为静态数据区，意思是这段内存专门用来保存数据，在程序运行期间一直存在
- 函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了
- 常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（ Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用

1. **什么是“栈溢出”？**

   - 程序在运行过程中，为了临时存取数据的需要，一般要从栈区中申请分配一些内存空间。如果向栈区中写入超过其本身长度的数据，以致于栈区无法容纳，就会造成栈区以外的存储单元被改写，这种现象就称为**栈溢出**

2. **堆区和栈区的区别是什么？**

   - 栈上的内存由系统自动分配和释放，不能由程序员控制；堆区的内存则由程序员自由地分配与释放
   - 函数执行结束后，先前被压入栈中的参数、局部变量、返回地址等信息都会被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部；而在堆区存放的信息在程序主动释放之前会一直存在，不随函数的结束而失效，在函数内部产生的数据只要放到堆中，就可以在函数外部使用

3. **程序运行过程中，内存模型当中的哪些区是只读的，哪些区是可读写的？**

   - 程序代码区、常量区只读；全局数据区，堆区，栈区可读写

4. **如何使用``malloc()``、``free()``函数，它们针对的哪一个区进行操作？**

   - ``malloc()`` 的函数说明：``void * malloc(int size);`` 

     ``malloc``向系统申请分配指定size个字节的内存空间，返回类型是void *类型。如果内存池中的可用内存可以满足这个需求，``malloc``就返回一个指向被分配的内存块起始位置的指针,否则返回空指针NULL

   - ``free()`` 的函数说明：``free( void * pointer);`` 

     ``free``用来释放内存，``free``函数的参数要么是NULL，要么是一个先前从``malloc``、``calloc``或``realloc``返回的值。向``free``传递一个NULL参数不会产生任何效果

   - 它们都是针对堆区进行操作

5. **为什么要对程序使用的内存进行管理？**

   - 以我拙见，因为电脑本身的内存不是无限的，所以需要将有限的空间合理地管理分配。程序要调用的内存空间不能太小，否则数据溢出，导致其它存储单元被改写，影响程序的运行；空间也不能太大，否则大量空间被浪费，其余程序会受到牵连，导致需要内存的地方空间不够、不需要太多空间的地方产生大量浪费
   - 此外，为实现程序的复杂运用，单一的内存管理方式显然不够。应该根据不同需求，申请不同种类的内存。比如，定义常量时，应提供不能改写的“常量区”内存；定义函数中的局部变量时，应提供可及时销毁信息的“栈区”内存，从而实现内存的“按需分配”。所以对程序使用的内存进行管理是必不可少的

## 内存模型的应用

- ``constValue``:常量区；只读不可被修改，即不能通过``constValue``修改对应内存中的值，从而保证在程序编写中不会手误更改其中的信息，导致错误。此外，位于常量区可以使其申请的空间在程序运行时一直存在，可在主函数与自定义函数中调用，修改
- ``constString``：常量区；与``constValue``类似，只读且运行时全程存在（ps.``constString``所指向空间的值不可以改变，但``constString++``是对的，p指针可以后移）
- ``globalVar``：全局数据区；``globalVar``作为全局变量，位于全局数据区则可以保证其内存空间在程序运行时一直存在，从而使该变量在``main()``函数，以及其它自定义函数中都可以调用其中的数据（不会像栈区内存那样被删掉）。并且位于全局数据区可以保证其可被修改（不同于只读的常量区）
- ``staticVar``：全局数据区；``staticVar``作为局部静态变量其可读可写，该区域中的数据在整个程序的运行期间一直占用这些存储空间（在程序整个运行期间都不释放），即其内存地址不变，直到整个程序运行结束。然而``staticVar``的数据不会随着函数的调用和退出而发生变化
- ``localVar``：栈区；``localVar``作为局部变量存放于栈区可读可写，且若函数被调用的话，无论是参数、还是返回地址等与函数相关的信息压入栈后，待函数执行结束，这些信息都将被销毁，从而保证其信息不能传递到函数外部
- ``ptr``：堆区；通过``malloc()`` 的函数来动态分配堆区空间，不同于栈区的空间，``ptr``的空间被申请后，若无人为释放其空间则会一直存在直到程序结束，从而保证其数据不随函数的结束而消失，在函数内外均可调用
- ``localVarMain``：栈区；``localVarMain``是在``main()``函数内部定义的局部变量，可读可写

## 浅谈Cache

1. **什么是冯诺伊曼体系结构？什么是现代计算机的组织结构？这两者的不同点在哪里？**

   - 冯诺伊曼机中计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备5大部分组成，运算器是中心，控制器通过控制线与各个部件通信

     其特点如下：

     1. 计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备 大部件组成
     2. 指令数据以同等地位存于存储器内，并可按地址寻访
     3. 指令和数据均用二进制代码表示的指令由操作码和地址码组成，操作码用来表示操作的性质 ，地址码用来表示操作数在存储器中的位置
     4. 指令在存储器内按顺序存放。通常，指令是顺序执行的，在特定条件下，可根据运算结果或根据设定的条件改变执行顺序
     5. 早期的冯诺依曼机以运算器为中心，输入／输出设备通过运算器与存储器传送数据

   - 现代计算机已经发展为以存储器为中心，使输入与输出操作绕开CPU而直接作用于存储器，以提高系统整体的运行效率。其核心原理为：用户输入的数据先放到内存当中，CPU 读取数据的时候就直接从内存当中读取，CPU 处理完数据后又写回内存当中，然后内存再将数据输出到输出设备当中，最后由输出设备进行输出显示

     总之，CPU 能且只能对内存进行读写，不能访问外设（输入或输出设备）；且外设（输入或输出设备）要输入或者输出数据，也只能写入内存或者从内存中读取

   - 我在学习过程中发现很多文章常把现代计算机的组织结构误当做冯诺依曼体系结构，我认为这说明以运算器为中心的思想已经基本被淘汰，才会出现这种张冠李戴的情况。在我看来两者相同点较多，现代计算机的组织结构在冯诺依曼体系上有一定的改进，不同点如下：

     1. 冯诺伊曼体系结构以运算器为中心；现代计算机的组织结构以存储器为中心
     2. 冯诺伊曼体系结构中CPU可直接作用于输入输出设备，现代计算机的组织结构中CPU直接作用于存储器，间接作用于输入输出设备（以存储器为媒介）
     3. 现代计算机的组织结构快于冯诺伊曼体系结构

2. **主存储器是如何工作的？**

   - 主存储器用来暂时存储CPU正在使用的数据与指令，和CPU关系最为密切；当前正在执行的程序和数据除了暂存于CPU的之外均存放于主存之中
   - 即从输入设备输入的数据与指令传入主存储器中，当CPU要执行指令，调用数据时，就从主存中获得；运算结束后再传入主存中，再通过输出设备将结果输出

3. **什么是Cache的局部性原理？它包括哪些方面的内容？**

   - 局部性原理是指：根据统计学原理，当一个数据正在被访问时，那么下一次有很大可能会访问其周围的数据，即对局部范围的存储器地址频繁访问，而对其他范围的访问甚少
   - Cache利用局部性原理：将常用的数据和指令从主存调入Cache，供CPU在一段时间内使用，从而提高访问速度
   - Cache的结构主要包括三部分：
     - 数据存储体：存放主存数据的副本
     - 标记存储体：存放标记，不同映射方式标记位数不同
     - 有效位：标识存放在Cache中的数据是否有效
   - Cache的组织及CPU访问Cache的流程
     - Cache命中：
       1. 对CPU访问存储器的地址进行逻辑划分，得到标记、索引、块内地址
       2. 按索引字段的值从Cache标记存储体的特定单元读出标记值，并比较
       3. 若命中，则形成Cache地址
       4. 访问Cache数据存储体，读取数据送至CPU
     - Cache不命中：
       1. 对CPU访问存储器的地址进行逻辑划分，得到标记、索引、块内地址
       2. 按索引字段的值从Cache标记存储体的特定单元读出标记值，并比较
       3. 若不命中，则进入Cache替换策略
       4. 调入数据块，更新标记存储体，送数据至CPU

4. **Cache的运用为什么可以加快系统整体性能？**

   - 由局部性原理知，Cache中存有大概率使用的数据与指令，供CPU在一段时间内直接使用（而非调用存储器中的数据），从而提高访问速度

## 代码优化

这里我们考虑一个简单的求和

```c
#include<stdio.h>
int main()
{
	int a[100],n,sum;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	printf("%d",sum);
	return 0;
}
```

然而目前的程序有以下两个不足：

1. 若n>100，此时n已大于数组空间，会发生栈溢出
2. 若n较小（比如n等于2，3），此时会浪费较大的空间

这里我们考虑用``malloc()``函数动态申请内存空间，从而解决上述两个存在的不足

```c
#include<stdio.h>
#include<stdlib.h>
int main()
{
	int sum,n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int* p=(int*)malloc(sizeof(int));
		scanf("%d",p);
		sum+=*p;
		free(p);
	}
	printf("%d",sum);
	return 0;
} 
```

